import type { AnalysisResult } from '../types/index.js';
import { getRiskEmoji, getRiskDescription } from './grade.js';

export function generateReport(
  analysisResult: AnalysisResult,
  format: 'markdown' | 'json'
): string {
  if (format === 'json') {
    return generateJSONReport(analysisResult);
  }
  return generateMarkdownReport(analysisResult);
}

function generateMarkdownReport(result: AnalysisResult): string {
  const {
    package: pkg,
    changelogDiff,
    breakingChanges,
    llmSummary,
    apiUsages,
    riskLevel,
    recommendation,
  } = result;

  const sections: string[] = [];

  // Header
  sections.push(`# Renovate Safety Analysis Report\n`);
  sections.push(`## ${getRiskEmoji(riskLevel)} Risk Assessment: ${riskLevel.toUpperCase()}\n`);

  // Package info
  sections.push(`### 📦 Package Update`);
  sections.push(`- **Package**: \`${pkg.name}\``);
  sections.push(`- **Version**: ${pkg.fromVersion} → ${pkg.toVersion}`);
  sections.push(`- **Changelog Source**: ${changelogDiff ? changelogDiff.source : 'Not found'}\n`);

  // Summary
  if (llmSummary) {
    sections.push(`### 📝 Summary`);
    sections.push(llmSummary.summary);

    if (llmSummary.breakingChanges.length > 0) {
      sections.push(`\n**AI-Identified Breaking Changes:**`);
      for (const change of llmSummary.breakingChanges) {
        sections.push(`- ${change}`);
      }
    }
    sections.push('');
  }

  // Breaking changes
  if (breakingChanges.length > 0) {
    sections.push(`### ⚠️ Breaking Changes Detected`);

    const grouped = groupBySeverity(breakingChanges);

    if (grouped.breaking.length > 0) {
      sections.push(`\n**🔴 Breaking (${grouped.breaking.length}):**`);
      for (const change of grouped.breaking) {
        sections.push(`- ${formatBreakingChange(change.line)}`);
      }
    }

    if (grouped.removal.length > 0) {
      sections.push(`\n**🟠 Removals (${grouped.removal.length}):**`);
      for (const change of grouped.removal) {
        sections.push(`- ${formatBreakingChange(change.line)}`);
      }
    }

    if (grouped.warning.length > 0) {
      sections.push(`\n**🟡 Warnings (${grouped.warning.length}):**`);
      for (const change of grouped.warning) {
        sections.push(`- ${formatBreakingChange(change.line)}`);
      }
    }

    sections.push('');
  }

  // API usage
  if (apiUsages.length > 0) {
    sections.push(`### 🔍 Affected Code Locations`);
    sections.push(`Found ${apiUsages.length} usage(s) of potentially affected APIs:\n`);

    // Group by API name
    const byApi = groupByApi(apiUsages);

    for (const [apiName, usages] of Object.entries(byApi)) {
      sections.push(`**\`${apiName}\`** (${usages.length} usage${usages.length > 1 ? 's' : ''}):`);
      for (const usage of usages.slice(0, 5)) {
        sections.push(`- ${usage.file}:${usage.line}`);
        sections.push(`  \`\`\`typescript`);
        sections.push(`  ${usage.snippet}`);
        sections.push(`  \`\`\``);
      }
      if (usages.length > 5) {
        sections.push(`- ... and ${usages.length - 5} more\n`);
      }
    }
    sections.push('');
  }

  // Recommendation
  sections.push(`### 💡 Recommendation`);
  sections.push(recommendation);
  sections.push('');

  // Risk details
  sections.push(`### 📊 Risk Details`);
  sections.push(`- **Risk Level**: ${riskLevel}`);
  sections.push(`- **Description**: ${getRiskDescription(riskLevel)}`);
  sections.push(`- **Breaking Changes Found**: ${breakingChanges.length}`);
  sections.push(`- **API Usages Found**: ${apiUsages.length}`);
  sections.push(`- **AI Analysis**: ${llmSummary ? 'Completed' : 'Skipped'}`);

  // Footer
  sections.push(`\n---`);
  sections.push(`*Generated by [renovate-safety](https://github.com/chaspy/renovate-safety)*`);

  return sections.join('\n');
}

function generateJSONReport(result: AnalysisResult): string {
  const report = {
    package: result.package,
    riskLevel: result.riskLevel,
    recommendation: result.recommendation,
    changelogSource: result.changelogDiff?.source || null,
    summary: result.llmSummary?.summary || null,
    breakingChanges: {
      total: result.breakingChanges.length,
      byType: {
        breaking: result.breakingChanges.filter((c) => c.severity === 'breaking').length,
        removal: result.breakingChanges.filter((c) => c.severity === 'removal').length,
        warning: result.breakingChanges.filter((c) => c.severity === 'warning').length,
      },
      items: result.breakingChanges,
    },
    apiUsages: {
      total: result.apiUsages.length,
      byApi: groupByApi(result.apiUsages),
      locations: result.apiUsages.map((u) => ({
        file: u.file,
        line: u.line,
        api: u.apiName,
        snippet: u.snippet,
      })),
    },
    aiAnalysis: result.llmSummary
      ? {
          summary: result.llmSummary.summary,
          language: result.llmSummary.language,
          identifiedBreakingChanges: result.llmSummary.breakingChanges,
        }
      : null,
  };

  return JSON.stringify(report, null, 2);
}

function groupBySeverity(changes: AnalysisResult['breakingChanges']) {
  return {
    breaking: changes.filter((c) => c.severity === 'breaking'),
    removal: changes.filter((c) => c.severity === 'removal'),
    warning: changes.filter((c) => c.severity === 'warning'),
  };
}

function groupByApi(usages: AnalysisResult['apiUsages']) {
  const grouped: Record<string, typeof usages> = {};

  for (const usage of usages) {
    if (!grouped[usage.apiName]) {
      grouped[usage.apiName] = [];
    }
    grouped[usage.apiName].push(usage);
  }

  return grouped;
}

function formatBreakingChange(line: string): string {
  // Clean up common prefixes
  return line
    .replace(/^[-*•]\s*/, '')
    .replace(/^\[BREAKING\]\s*/i, '')
    .replace(/^BREAKING:\s*/i, '')
    .replace(/^BREAKING CHANGE:\s*/i, '')
    .trim();
}
