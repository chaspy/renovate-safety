// Helper functions for report-generator workflow to reduce complexity

export type Assessment = {
  dependency: {
    name: string;
    fromVersion: string;
    toVersion: string;
  };
  risk: {
    level: string;
  };
  codeImpact?: {
    totalUsages?: number;
    recommendations?: string[];
  };
  releaseNotes?: {
    breakingChanges?: Array<{ text: string }>;
  };
};

export function generateSummaryTable(assessments: Assessment[], isJapanese: boolean): string {
  let markdown = `| Package | Version | ${isJapanese ? 'ãƒªã‚¹ã‚¯' : 'Risk'} | ${isJapanese ? 'å½±éŸ¿' : 'Impact'} |\n`;
  markdown += `|---------|---------|--------|--------|\n`;

  for (const assessment of assessments) {
    const { dependency, risk, codeImpact } = assessment;
    const riskBadge = getRiskEmoji(risk.level);
    const usageCount = codeImpact?.totalUsages || 0;

    markdown += `| ${dependency.name} | ${dependency.fromVersion} â†’ ${dependency.toVersion} | `;
    markdown += `${riskBadge} ${risk.level} | `;
    markdown += `${usageCount} ${isJapanese ? 'ç®‡æ‰€' : 'usages'} |\n`;
  }

  return markdown;
}

export function generateBreakingChangesSection(assessments: Assessment[], isJapanese: boolean): string {
  const hasBreaking = assessments.some(a =>
    a.releaseNotes?.breakingChanges && a.releaseNotes.breakingChanges.length > 0
  );

  if (!hasBreaking) {
    return '';
  }

  let markdown = `\n### ${isJapanese ? 'âš ï¸ ç ´å£Šçš„å¤‰æ›´' : 'âš ï¸ Breaking Changes'}\n\n`;

  for (const assessment of assessments) {
    const breakingChanges = assessment.releaseNotes?.breakingChanges;
    if (breakingChanges && breakingChanges.length > 0) {
      markdown += `**${assessment.dependency.name}**:\n`;
      markdown += formatBreakingChangesList(breakingChanges, isJapanese);
    }
  }

  return markdown;
}

function formatBreakingChangesList(breakingChanges: Array<{ text: string }>, isJapanese: boolean): string {
  let markdown = '';
  const displayLimit = 3;

  for (const breaking of breakingChanges.slice(0, displayLimit)) {
    markdown += `- ${breaking.text}\n`;
  }

  if (breakingChanges.length > displayLimit) {
    const remaining = breakingChanges.length - displayLimit;
    markdown += isJapanese
      ? `- ... ä»–${remaining}é …ç›®\n`
      : `- ... and ${remaining} more\n`;
  }

  return markdown;
}

export function generateRecommendationsSection(
  assessments: Assessment[],
  overallRisk: string,
  isJapanese: boolean
): string {
  let markdown = `\n### ${isJapanese ? 'ğŸ“Œ æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³' : 'ğŸ“Œ Recommendations'}\n\n`;

  if (overallRisk === 'safe') {
    return markdown + (isJapanese
      ? 'âœ… è‡ªå‹•ãƒãƒ¼ã‚¸å¯èƒ½ï¼ˆãƒªã‚¹ã‚¯ãªã—ï¼‰\n'
      : 'âœ… Safe to auto-merge (no risks detected)\n');
  }

  if (overallRisk === 'low') {
    return markdown + (isJapanese
      ? 'âœ… ãƒ†ã‚¹ãƒˆé€šéå¾Œã«ãƒãƒ¼ã‚¸æ¨å¥¨\n'
      : 'âœ… Merge after tests pass\n');
  }

  // High risk cases
  markdown += isJapanese
    ? 'ğŸ” æ‰‹å‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒå¿…è¦ã§ã™\n'
    : 'ğŸ” Manual review required\n';

  // Add specific actions for high-risk items
  const highRiskRecommendations = getHighRiskRecommendations(assessments);
  for (const rec of highRiskRecommendations) {
    markdown += `- ${rec}\n`;
  }

  return markdown;
}

function getHighRiskRecommendations(assessments: Assessment[]): string[] {
  const recommendations: string[] = [];
  const highRiskAssessments = assessments.filter(a =>
    a.risk.level === 'medium' || a.risk.level === 'high' || a.risk.level === 'critical'
  );

  for (const assessment of highRiskAssessments) {
    if (assessment.codeImpact?.recommendations) {
      recommendations.push(...assessment.codeImpact.recommendations.slice(0, 2));
    }
  }

  return recommendations;
}

export function generateReportHeader(overallRisk: string, isJapanese: boolean): string {
  const riskEmoji = getRiskEmoji(overallRisk);
  let markdown = `### ${isJapanese ? 'renovate-safety åˆ†æçµæœ' : 'renovate-safety Analysis'}\n\n`;
  markdown += `**${isJapanese ? 'çµè«–' : 'Conclusion'}**: ${riskEmoji} ${overallRisk.toUpperCase()}\n\n`;
  return markdown;
}

export function generateReportFooter(): string {
  let markdown = `\n---\n`;
  markdown += `*Generated by [renovate-safety](https://github.com/chaspy/renovate-safety) agent v2.0*\n`;
  markdown += `<!-- Generated by renovate-safety (do-not-edit) -->\n`;
  return markdown;
}

export function getRiskEmoji(level: string): string {
  switch (level) {
    case 'safe': return 'âœ…';
    case 'low': return 'ğŸŸ¡';
    case 'medium': return 'ğŸŸ ';
    case 'high': return 'ğŸ”´';
    case 'critical': return 'ğŸ’¥';
    default: return 'â“';
  }
}

export function getHighestRisk(assessments: Assessment[]): string {
  const riskLevels = ['safe', 'low', 'medium', 'high', 'critical'];
  let highestLevel = 'safe';
  let highestIndex = 0;

  for (const assessment of assessments) {
    const index = riskLevels.indexOf(assessment.risk.level);
    if (index > highestIndex) {
      highestIndex = index;
      highestLevel = assessment.risk.level;
    }
  }

  return highestLevel;
}