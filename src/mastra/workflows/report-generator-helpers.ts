// Helper functions for report-generator workflow to reduce complexity

export type Assessment = {
  dependency: {
    name: string;
    fromVersion: string;
    toVersion: string;
  };
  risk: {
    level: string;
  };
  codeImpact?: {
    totalUsages?: number;
    recommendations?: string[];
  };
  releaseNotes?: {
    breakingChanges?: Array<{ text: string }>;
  };
};

export function generateSummaryTable(assessments: Assessment[], isJapanese: boolean): string {
  let markdown = `| Package | Version | ${isJapanese ? 'リスク' : 'Risk'} | ${isJapanese ? '影響' : 'Impact'} |\n`;
  markdown += `|---------|---------|--------|--------|\n`;

  for (const assessment of assessments) {
    const { dependency, risk, codeImpact } = assessment;
    const riskBadge = getRiskEmoji(risk.level);
    const usageCount = codeImpact?.totalUsages || 0;

    markdown += `| ${dependency.name} | ${dependency.fromVersion} → ${dependency.toVersion} | `;
    markdown += `${riskBadge} ${risk.level} | `;
    markdown += `${usageCount} ${isJapanese ? '箇所' : 'usages'} |\n`;
  }

  return markdown;
}

export function generateBreakingChangesSection(assessments: Assessment[], isJapanese: boolean): string {
  const hasBreaking = assessments.some(a =>
    a.releaseNotes?.breakingChanges && a.releaseNotes.breakingChanges.length > 0
  );

  if (!hasBreaking) {
    return '';
  }

  let markdown = `\n### ${isJapanese ? '⚠️ 破壊的変更' : '⚠️ Breaking Changes'}\n\n`;

  for (const assessment of assessments) {
    const breakingChanges = assessment.releaseNotes?.breakingChanges;
    if (breakingChanges && breakingChanges.length > 0) {
      markdown += `**${assessment.dependency.name}**:\n`;
      markdown += formatBreakingChangesList(breakingChanges, isJapanese);
    }
  }

  return markdown;
}

function formatBreakingChangesList(breakingChanges: Array<{ text: string }>, isJapanese: boolean): string {
  let markdown = '';
  const displayLimit = 3;

  for (const breaking of breakingChanges.slice(0, displayLimit)) {
    markdown += `- ${breaking.text}\n`;
  }

  if (breakingChanges.length > displayLimit) {
    const remaining = breakingChanges.length - displayLimit;
    markdown += isJapanese
      ? `- ... 他${remaining}項目\n`
      : `- ... and ${remaining} more\n`;
  }

  return markdown;
}

export function generateRecommendationsSection(
  assessments: Assessment[],
  overallRisk: string,
  isJapanese: boolean
): string {
  let markdown = `\n### ${isJapanese ? '📌 推奨アクション' : '📌 Recommendations'}\n\n`;

  if (overallRisk === 'safe') {
    return markdown + (isJapanese
      ? '✅ 自動マージ可能（リスクなし）\n'
      : '✅ Safe to auto-merge (no risks detected)\n');
  }

  if (overallRisk === 'low') {
    return markdown + (isJapanese
      ? '✅ テスト通過後にマージ推奨\n'
      : '✅ Merge after tests pass\n');
  }

  // High risk cases
  markdown += isJapanese
    ? '🔍 手動レビューが必要です\n'
    : '🔍 Manual review required\n';

  // Add specific actions for high-risk items
  const highRiskRecommendations = getHighRiskRecommendations(assessments);
  for (const rec of highRiskRecommendations) {
    markdown += `- ${rec}\n`;
  }

  return markdown;
}

function getHighRiskRecommendations(assessments: Assessment[]): string[] {
  const recommendations: string[] = [];
  const highRiskAssessments = assessments.filter(a =>
    a.risk.level === 'medium' || a.risk.level === 'high' || a.risk.level === 'critical'
  );

  for (const assessment of highRiskAssessments) {
    if (assessment.codeImpact?.recommendations) {
      recommendations.push(...assessment.codeImpact.recommendations.slice(0, 2));
    }
  }

  return recommendations;
}

export function generateReportHeader(overallRisk: string, isJapanese: boolean): string {
  const riskEmoji = getRiskEmoji(overallRisk);
  let markdown = `### ${isJapanese ? 'renovate-safety 分析結果' : 'renovate-safety Analysis'}\n\n`;
  markdown += `**${isJapanese ? '結論' : 'Conclusion'}**: ${riskEmoji} ${overallRisk.toUpperCase()}\n\n`;
  return markdown;
}

export function generateReportFooter(): string {
  let markdown = `\n---\n`;
  markdown += `*Generated by [renovate-safety](https://github.com/chaspy/renovate-safety) agent v2.0*\n`;
  markdown += `<!-- Generated by renovate-safety (do-not-edit) -->\n`;
  return markdown;
}

export function getRiskEmoji(level: string): string {
  switch (level) {
    case 'safe': return '✅';
    case 'low': return '🟡';
    case 'medium': return '🟠';
    case 'high': return '🔴';
    case 'critical': return '💥';
    default: return '❓';
  }
}

export function getHighestRisk(assessments: Assessment[]): string {
  const riskLevels = ['safe', 'low', 'medium', 'high', 'critical'];
  let highestLevel = 'safe';
  let highestIndex = 0;

  for (const assessment of assessments) {
    const index = riskLevels.indexOf(assessment.risk.level);
    if (index > highestIndex) {
      highestIndex = index;
      highestLevel = assessment.risk.level;
    }
  }

  return highestLevel;
}