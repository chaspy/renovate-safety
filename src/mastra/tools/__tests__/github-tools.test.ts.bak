import { describe, it, expect, vi, beforeEach } from 'vitest';

// Mock dependencies before importing the modules
vi.mock('../../lib/secure-exec.js', async () => {
  const actual = await vi.importActual<typeof import('../../lib/secure-exec.js')>('../../lib/secure-exec.js');
  return {
    ...actual,
    secureSystemExec: vi.fn(),
  };
});

vi.mock('../../lib/env-config.js', async () => {
  const actual = await vi.importActual<typeof import('../../lib/env-config.js')>('../../lib/env-config.js');
  return {
    ...actual,
    getEnvironmentConfig: vi.fn(),
  };
});

vi.mock('@octokit/rest', () => {
  const MockedOctokit = vi.fn().mockImplementation(() => ({
    request: vi.fn(),
    repos: {
      compareCommits: vi.fn(),
    },
    pulls: {
      get: vi.fn(),
    },
    issues: {
      listLabelsOnIssue: vi.fn(),
      addLabels: vi.fn(),
      removeLabel: vi.fn(),
    },
  }));
  return { Octokit: MockedOctokit };
});

vi.mock('../../lib/safe-json.js', async () => {
  const actual = await vi.importActual<typeof import('../../lib/safe-json.js')>('../../lib/safe-json.js');
  return {
    ...actual,
    safeJsonParse: vi.fn(),
  };
});

// Import after mocking
import { getPRInfoTool, githubCompareTool, prCommentTool, prLabelTool, dependencyReviewTool } from '../index.js';
import { secureSystemExec } from '../../lib/secure-exec.js';
import { getEnvironmentConfig } from '../../lib/env-config.js';
import { Octokit } from '@octokit/rest';
import { safeJsonParse } from '../../lib/safe-json.js';

const mockSecureSystemExec = vi.mocked(secureSystemExec);
const mockGetEnvironmentConfig = vi.mocked(getEnvironmentConfig);
const mockOctokitClass = vi.mocked(Octokit);
const mockSafeJsonParse = vi.mocked(safeJsonParse);

const mockOctokit = {
  request: vi.fn(),
  repos: {
    compareCommits: vi.fn(),
  },
  pulls: {
    get: vi.fn(),
  },
  issues: {
    listLabelsOnIssue: vi.fn(),
    addLabels: vi.fn(),
    removeLabel: vi.fn(),
  },
};

beforeEach(() => {
  vi.clearAllMocks();

  mockGetEnvironmentConfig.mockReturnValue({
    githubToken: 'test-token',
  });

  mockOctokitClass.mockReturnValue(mockOctokit as any);
});

describe('GitHub Tools', () => {
  describe('getPRInfoTool', () => {
    it('should extract PR information using gh CLI', async () => {
      const mockPRData = {
        number: 123,
        title: 'Update dependency @types/node to v24.0.7',
        body: 'Renovate update',
        baseRefName: 'main',
        headRefName: 'renovate/node-24.x',
        state: 'open',
        author: { login: 'renovate[bot]' },
      };

      mockSecureSystemExec.mockResolvedValue({
        success: true,
        stdout: JSON.stringify(mockPRData),
      });

      mockSafeJsonParse.mockReturnValue(mockPRData);

      const result = await getPRInfoTool.execute({ 
        context: { prNumber: 123 },
        runtimeContext: {}
      });

      expect(result.success).toBe(true);
      expect(result.data?.number).toBe(123);
      expect(result.data?.title).toBe('Update dependency @types/node to v24.0.7');
      expect(result.data?.base).toBe('main');
      expect(result.data?.head).toBe('renovate/node-24.x');
    });

    it('should fallback to Octokit when gh CLI fails', async () => {
      mockSecureSystemExec
        .mockResolvedValueOnce({
          success: false,
          error: 'gh not found',
        })
        .mockResolvedValueOnce({
          success: true,
          stdout: 'https://github.com/owner/repo.git',
        });

      mockOctokit.pulls.get.mockResolvedValue({
        data: {
          number: 123,
          title: 'Update dependency',
          body: 'Test PR body',
          base: { ref: 'main' },
          head: { ref: 'feature-branch' },
          state: 'open',
          user: { login: 'test-user' },
        },
      });

      const result = await getPRInfoTool.execute({ 
        context: { prNumber: 123 },
        runtimeContext: {}
      });

      expect(result.success).toBe(true);
      expect(result.data?.number).toBe(123);
      expect(mockOctokit.pulls.get).toHaveBeenCalledWith({
        owner: 'owner',
        repo: 'repo',
        pull_number: 123,
      });
    });
  });

  describe('githubCompareTool', () => {
    it('should detect lockfile-only changes', async () => {
      mockOctokit.repos.compareCommits.mockResolvedValue({
        data: {
          files: [
            {
              filename: 'package-lock.json',
              status: 'modified',
              additions: 10,
              deletions: 5,
              changes: 15,
            },
          ],
          ahead_by: 1,
          behind_by: 0,
          total_commits: 1,
        },
      });

      const result = await githubCompareTool.execute({
        context: {
          owner: 'test-owner',
          repo: 'test-repo',
          base: 'main',
          head: 'feature',
        },
        runtimeContext: {}
      });

      expect(result.success).toBe(true);
      expect(result.data?.isLockfileOnly).toBe(true);
      expect(result.data?.lockfileCount).toBe(1);
      expect(result.data?.sourceFileCount).toBe(0);
    });

    it('should detect mixed changes (source + lockfile)', async () => {
      mockOctokit.repos.compareCommits.mockResolvedValue({
        data: {
          files: [
            {
              filename: 'package-lock.json',
              status: 'modified',
              additions: 10,
              deletions: 5,
              changes: 15,
            },
            {
              filename: 'src/index.ts',
              status: 'modified',
              additions: 2,
              deletions: 1,
              changes: 3,
            },
          ],
          ahead_by: 1,
          behind_by: 0,
          total_commits: 1,
        },
      });

      const result = await githubCompareTool.execute({
        context: {
          owner: 'test-owner',
          repo: 'test-repo',
          base: 'main',
          head: 'feature',
        },
        runtimeContext: {}
      });

      expect(result.success).toBe(true);
      expect(result.data?.isLockfileOnly).toBe(false);
      expect(result.data?.lockfileCount).toBe(1);
      expect(result.data?.sourceFileCount).toBe(1);
    });
  });

  describe('prCommentTool', () => {
    it('should create new comment', async () => {
      mockSecureSystemExec.mockResolvedValue({
        success: true,
        stdout: '',
      });

      const result = await prCommentTool.execute({
        context: {
          prNumber: 123,
          body: 'Test comment',
          mode: 'create' as const,
        },
        runtimeContext: {}
      });

      expect(result.success).toBe(true);
      expect(result.created).toBe(true);
    });

    it('should check for existing comments', async () => {
      mockSecureSystemExec.mockResolvedValue({
        success: true,
        stdout: '12345',
      });

      const result = await prCommentTool.execute({
        context: {
          prNumber: 123,
          body: 'Test comment',
          mode: 'check' as const,
        },
        runtimeContext: {}
      });

      expect(result.success).toBe(true);
      expect(result.exists).toBe(true);
      expect(result.commentId).toBe(12345);
    });
  });

  describe('prLabelTool', () => {
    it('should add labels to PR', async () => {
      mockSecureSystemExec.mockResolvedValue({
        success: true,
        stdout: 'https://github.com/owner/repo.git',
      });

      mockOctokit.issues.listLabelsOnIssue.mockResolvedValue({
        data: [
          { name: 'existing-label' },
        ],
      });

      mockOctokit.issues.addLabels.mockResolvedValue({
        data: [
          { name: 'existing-label' },
          { name: 'new-label' },
        ],
      });

      const result = await prLabelTool.execute({
        context: {
          prNumber: 123,
          labels: ['new-label'],
          operation: 'add' as const,
        },
        runtimeContext: {}
      });

      expect(result.success).toBe(true);
      expect(result.labelsAdded).toContain('new-label');
    });
  });

  describe('dependencyReviewTool', () => {
    it('should get dependency changes from GitHub API', async () => {
      mockOctokit.request.mockResolvedValue({
        data: [
          {
            name: '@types/node',
            version_before: '24.0.6',
            version_after: '24.0.7',
            change_type: 'updated',
            manifest: 'package.json',
            scope: 'runtime',
            vulnerabilities: [],
          },
        ],
      });

      const result = await dependencyReviewTool.execute({
        context: {
          owner: 'test-owner',
          repo: 'test-repo',
          base: 'main',
          head: 'feature',
        },
        runtimeContext: {}
      });

      expect(result.success).toBe(true);
      expect(result.data).toHaveLength(1);
      expect(result.data?.[0].name).toBe('@types/node');
      expect(result.data?.[0].fromVersion).toBe('24.0.6');
      expect(result.data?.[0].toVersion).toBe('24.0.7');
    });

    it('should handle API failures gracefully', async () => {
      mockGetEnvironmentConfig.mockReturnValue({
        githubToken: '',
      });

      const result = await dependencyReviewTool.execute({
        context: {
          owner: 'test-owner',
          repo: 'test-repo',
          base: 'main',
          head: 'feature',
        },
        runtimeContext: {}
      });

      expect(result.success).toBe(false);
      expect(result.error).toBe('No GitHub authentication available');
      expect(result.fallback).toBeDefined();
    });
  });
});