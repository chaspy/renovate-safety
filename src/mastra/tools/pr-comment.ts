import { createTool } from '@mastra/core/tools';
import { z } from 'zod';
import * as fs from 'fs/promises';
import * as path from 'path';
import { tmpdir } from 'os';
import { randomBytes } from 'crypto';
import { secureSystemExec } from '../../lib/secure-exec.js';

const inputSchema = z.object({
  prNumber: z.number().describe('PR number'),
  body: z.string().describe('Comment body content'),
  mode: z.enum(['create', 'update', 'check']).default('create').describe('Operation mode'),
  marker: z.string().default('Generated by [renovate-safety]').describe('Unique marker to identify renovate-safety comments'),
});

const outputSchema = z.object({
  success: z.boolean(),
  exists: z.boolean().optional(),
  commentId: z.number().optional(),
  totalMatches: z.number().optional(),
  updated: z.boolean().optional(),
  created: z.boolean().optional(),
  error: z.string().optional(),
});

// Find existing comment with marker
async function findExistingComment(
  prNumber: number,
  marker: string
): Promise<{ success: boolean; commentIds: string[] }> {
  const findResult = await secureSystemExec('gh', [
    'api',
    `repos/{owner}/{repo}/issues/${prNumber}/comments`,
    '--jq',
    `.[] | select(.body | contains("${marker}")) | .id`,
  ]);

  if (findResult.success && findResult.stdout.trim()) {
    return {
      success: true,
      commentIds: findResult.stdout.trim().split('\n'),
    };
  }

  return { success: false, commentIds: [] };
}

// Create temporary file with content
async function createTempFile(content: string, prefix: string): Promise<string> {
  const randomSuffix = randomBytes(8).toString('hex');
  const tempFile = path.join(tmpdir(), `${prefix}-${randomSuffix}.md`);
  await fs.writeFile(tempFile, content, 'utf-8');
  return tempFile;
}

// Clean up temporary file
async function cleanupTempFile(tempFile: string): Promise<void> {
  try {
    await fs.unlink(tempFile);
  } catch {
    // Ignore cleanup errors
  }
}

// Update existing comment
async function updateComment(
  commentId: number,
  body: string
): Promise<{ success: boolean; error?: string }> {
  const tempFile = await createTempFile(body, 'renovate-safety-update');

  try {
    const updateResult = await secureSystemExec('gh', [
      'api',
      `repos/{owner}/{repo}/issues/comments/${commentId}`,
      '-X',
      'PATCH',
      '-F',
      `body=@${tempFile}`,
    ]);

    return {
      success: updateResult.success,
      error: updateResult.success ? undefined : updateResult.error,
    };
  } finally {
    await cleanupTempFile(tempFile);
  }
}

// Create new comment
async function createComment(
  prNumber: number,
  body: string
): Promise<{ success: boolean; error?: string }> {
  const tempFile = await createTempFile(body, 'renovate-safety-report');

  try {
    const createResult = await secureSystemExec('gh', [
      'pr',
      'comment',
      prNumber.toString(),
      '--body-file',
      tempFile,
    ]);

    return {
      success: createResult.success,
      error: createResult.success ? undefined : createResult.error,
    };
  } finally {
    await cleanupTempFile(tempFile);
  }
}

// Handle check mode
async function handleCheckMode(
  prNumber: number,
  marker: string
): Promise<any> {
  const { success, commentIds } = await findExistingComment(prNumber, marker);

  if (success && commentIds.length > 0) {
    const commentId = parseInt(commentIds[0], 10);
    return {
      success: true,
      exists: true,
      commentId,
      totalMatches: commentIds.length,
    };
  }

  return {
    success: true,
    exists: false,
  };
}

// Handle update mode
async function handleUpdateMode(
  prNumber: number,
  body: string,
  marker: string
): Promise<any> {
  const { success, commentIds } = await findExistingComment(prNumber, marker);

  if (success && commentIds.length > 0) {
    const commentId = parseInt(commentIds[0], 10);
    const updateResult = await updateComment(commentId, body);

    return {
      success: updateResult.success,
      updated: true,
      commentId,
      error: updateResult.error,
    };
  }

  // Fall back to create if no existing comment found
  const createResult = await createComment(prNumber, body);
  return {
    success: createResult.success,
    created: true,
    error: createResult.error,
  };
}

// Parse error message and return appropriate response
function parseErrorResponse(error: unknown, prNumber: number): any {
  const errorMessage = error instanceof Error ? error.message : String(error);

  if (errorMessage.includes('gh: command not found')) {
    return {
      success: false,
      error: 'GitHub CLI (gh) is not installed. Please install it from https://cli.github.com/',
    };
  }

  if (errorMessage.includes('not authenticated')) {
    return {
      success: false,
      error: 'GitHub CLI is not authenticated. Run "gh auth login" first.',
    };
  }

  if (errorMessage.includes('404')) {
    return {
      success: false,
      error: `PR #${prNumber} not found. Make sure you're in the correct repository.`,
    };
  }

  return {
    success: false,
    error: errorMessage,
  };
}

export const prCommentTool = createTool({
  id: 'pr-comment',
  description: 'Post, update, or check comments on PR with renovate-safety marker',
  inputSchema,
  outputSchema,
  execute: async ({ context: {
    prNumber,
    body,
    mode = 'create',
    marker = 'Generated by [renovate-safety]'
  } }) => {
    try {
      switch (mode) {
        case 'check':
          return await handleCheckMode(prNumber, marker);

        case 'update':
          return await handleUpdateMode(prNumber, body, marker);

        case 'create':
          const createResult = await createComment(prNumber, body);
          return {
            success: createResult.success,
            created: true,
            error: createResult.error,
          };

        default:
          return {
            success: false,
            error: 'Invalid operation mode',
          };
      }
    } catch (error: unknown) {
      return parseErrorResponse(error, prNumber);
    }
  },
});