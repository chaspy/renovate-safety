import { createTool } from '@mastra/core/tools';
import { z } from 'zod';
import * as fs from 'fs/promises';
import * as path from 'path';
import { tmpdir } from 'os';
import { randomBytes } from 'crypto';
import { secureSystemExec } from '../../lib/secure-exec.js';

const inputSchema = z.object({
  prNumber: z.number().describe('PR number'),
  body: z.string().describe('Comment body content'),
  mode: z.enum(['create', 'update', 'check']).default('create').describe('Operation mode'),
  marker: z.string().default('Generated by [renovate-safety]').describe('Unique marker to identify renovate-safety comments'),
});

const outputSchema = z.object({
  success: z.boolean(),
  exists: z.boolean().optional(),
  commentId: z.number().optional(),
  totalMatches: z.number().optional(),
  updated: z.boolean().optional(),
  created: z.boolean().optional(),
  error: z.string().optional(),
});

export const prCommentTool = createTool({
  id: 'pr-comment',
  description: 'Post, update, or check comments on PR with renovate-safety marker',
  inputSchema,
  outputSchema,
  execute: async ({ context: { 
    prNumber, 
    body, 
    mode = 'create',
    marker = 'Generated by [renovate-safety]'
  } }) => {
    try {
      // 既存コメントの検索（マーカーで識別）
      if (mode === 'check' || mode === 'update') {
        const findResult = await secureSystemExec('gh', [
          'api',
          `repos/{owner}/{repo}/issues/${prNumber}/comments`,
          '--jq',
          `.[] | select(.body | contains("${marker}")) | .id`,
        ]);

        if (findResult.success && findResult.stdout.trim()) {
          const commentIds = findResult.stdout.trim().split('\n');
          const commentId = parseInt(commentIds[0], 10);

          if (mode === 'check') {
            return { 
              success: true,
              exists: true, 
              commentId,
              totalMatches: commentIds.length 
            };
          }

          // 既存コメントを更新
          if (mode === 'update') {
            // Create a temporary file for the report content with secure random name
            const randomSuffix = randomBytes(8).toString('hex');
            const tempFile = path.join(tmpdir(), `renovate-safety-update-${randomSuffix}.md`);

            try {
              // Write report to temp file
              await fs.writeFile(tempFile, body, 'utf-8');

              const updateResult = await secureSystemExec('gh', [
                'api',
                `repos/{owner}/{repo}/issues/comments/${commentId}`,
                '-X',
                'PATCH',
                '-F',
                `body=@${tempFile}`,
              ]);

              return {
                success: updateResult.success,
                updated: true,
                commentId,
                error: updateResult.success ? undefined : updateResult.error,
              };
            } finally {
              // Clean up temp file
              try {
                await fs.unlink(tempFile);
              } catch {
                // Ignore cleanup errors
              }
            }
          }
        } else if (mode === 'check') {
          return {
            success: true,
            exists: false,
          };
        }
      }

      // 新規コメント作成
      if (mode === 'create' || mode === 'update') {
        // Create a temporary file for the report content with secure random name
        const randomSuffix = randomBytes(8).toString('hex');
        const tempFile = path.join(tmpdir(), `renovate-safety-report-${randomSuffix}.md`);

        try {
          // Write report to temp file
          await fs.writeFile(tempFile, body, 'utf-8');

          const createResult = await secureSystemExec('gh', [
            'pr',
            'comment',
            prNumber.toString(),
            '--body-file',
            tempFile,
          ]);

          return {
            success: createResult.success,
            created: true,
            error: createResult.success ? undefined : createResult.error,
          };
        } finally {
          // Clean up temp file
          try {
            await fs.unlink(tempFile);
          } catch {
            // Ignore cleanup errors
          }
        }
      }

      return {
        success: false,
        error: 'Invalid operation mode',
      };
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      
      // Handle specific error cases
      if (errorMessage.includes('gh: command not found')) {
        return {
          success: false,
          error: 'GitHub CLI (gh) is not installed. Please install it from https://cli.github.com/',
        };
      }

      if (errorMessage.includes('not authenticated')) {
        return {
          success: false,
          error: 'GitHub CLI is not authenticated. Run "gh auth login" first.',
        };
      }

      if (errorMessage.includes('404')) {
        return {
          success: false,
          error: `PR #${prNumber} not found. Make sure you're in the correct repository.`,
        };
      }

      return {
        success: false,
        error: errorMessage,
      };
    }
  },
});