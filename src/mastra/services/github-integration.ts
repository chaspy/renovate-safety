/**
 * GitHub Integration Service
 * Handles GitHub API interactions including PR comments and labels
 */

import { 
  getPRInfoTool,
  dependencyReviewTool,
  githubCompareTool,
  prCommentTool,
  prLabelTool
} from '../tools/index.js';
import { RuntimeContext } from '@mastra/core/runtime-context';

export type GitHubGitHubPRInfo = {
  number: number;
  title: string;
  base: string;
  head: string;
  repository: {
    owner: string;
    name: string;
  };
};

/**
 * Fetch PR information directly using tools (no Agent wrapper)
 */
export async function fetchGitHubPRInfo(prNumber: number): Promise<any> {
  try {
    const result = await getPRInfoTool.execute({
      context: {
        prNumber,
        includeBaseRepository: true
      },
      runtimeContext: new RuntimeContext()
    });
    
    if (!result.success || !result.data) {
      throw new Error(`Failed to get PR info: ${result.error || 'Unknown error'}`);
    }
    
    return result.data;
  } catch (error) {
    throw new Error(`Failed to fetch PR info: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Get dependency changes directly using tools (no Agent wrapper)
 */
export async function getDependencyChanges(prInfo: GitHubPRInfo): Promise<any> {
  const owner = prInfo.repository?.owner || 'unknown';
  const repo = prInfo.repository?.name || 'unknown';
  
  try {
    const result = await dependencyReviewTool.execute({
      context: {
        owner,
        repo,
        base: prInfo.base,
        head: prInfo.head
      },
      runtimeContext: new RuntimeContext()
    });
    
    if (!result.success || !result.data) {
      throw new Error(`Failed to get dependencies: ${result.error || 'Unknown error'}`);
    }
    
    return result.data;
  } catch (error) {
    throw new Error(`Failed to get dependency changes: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Compare branches directly using tools (no Agent wrapper)
 */
export async function compareBranches(prInfo: GitHubPRInfo): Promise<any> {
  const owner = prInfo.repository?.owner || 'unknown';
  const repo = prInfo.repository?.name || 'unknown';
  
  try {
    const result = await githubCompareTool.execute({
      context: {
        owner,
        repo,
        base: prInfo.base,
        head: prInfo.head
      },
      runtimeContext: new RuntimeContext()
    });
    
    if (!result.success || !result.data) {
      throw new Error(`Failed to compare branches: ${result.error || 'Unknown error'}`);
    }
    
    return result.data;
  } catch (error) {
    throw new Error(`Failed to compare branches: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Check for existing PR comments
 */
export async function checkExistingComment(prInfo: GitHubPRInfo): Promise<{ exists: boolean; commentId?: string }> {
  try {
    const result = await prCommentTool.execute({
      context: {
        prNumber: prInfo.number,
        body: '',
        mode: 'check' as const,
        marker: 'Generated by [renovate-safety]'
      },
      runtimeContext: new RuntimeContext()
    });
    
    return { exists: !!result.exists, commentId: result.commentId?.toString() };
  } catch (error) {
    console.warn('Failed to check existing comment:', error);
    return { exists: false };
  }
}

/**
 * Post or update PR comment
 */
export async function postPRComment(
  prInfo: GitHubPRInfo, 
  body: string, 
  mode: 'create' | 'update' = 'create'
): Promise<void> {
  try {
    await prCommentTool.execute({
      context: {
        prNumber: prInfo.number,
        body,
        mode: mode,
        marker: 'Generated by [renovate-safety]'
      },
      runtimeContext: new RuntimeContext()
    });
  } catch (error) {
    throw new Error(`Failed to ${mode} PR comment: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Add label to PR
 */
export async function addPRLabel(prInfo: GitHubPRInfo, label: string): Promise<void> {
  try {
    await prLabelTool.execute({
      context: {
        prNumber: prInfo.number,
        labels: [label],
        operation: 'add' as const
      },
      runtimeContext: new RuntimeContext()
    });
  } catch (error) {
    throw new Error(`Failed to add PR label: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Handle PR posting with proper mode detection
 */
export async function handlePRPosting(
  prInfo: GitHubPRInfo,
  reportBody: string,
  postMode: string,
  riskLevel: string
): Promise<boolean> {
  if (postMode === 'never') {
    console.log('üîï Skip PR posting (postMode: never)');
    return false;
  }

  console.log(`üìù Posting to PR #${prInfo.number} (mode: ${postMode})`);
  
  try {
    // Check for existing comment
    console.log('üîç Checking for existing comment...');
    const existingComment = await checkExistingComment(prInfo);
    console.log(`Found existing comment: ${existingComment.exists} (ID: ${existingComment.commentId})`);
    
    const commentMode = existingComment.exists && postMode === 'update' 
      ? 'update' as const
      : 'create' as const;

    console.log(`üí¨ ${commentMode === 'create' ? 'Creating' : 'Updating'} PR comment...`);

    // Post or update comment
    await postPRComment(
      prInfo, 
      reportBody, 
      commentMode
    );

    console.log(`‚úÖ Successfully ${commentMode === 'create' ? 'created' : 'updated'} PR comment`);

    // Add label based on risk level
    console.log(`üè∑Ô∏è  Adding label: renovate-safety:${riskLevel}`);
    await addPRLabel(prInfo, `renovate-safety:${riskLevel}`);

    console.log('‚úÖ Successfully added PR label');
    return true;
  } catch (error) {
    console.error('‚ùå Failed to post to PR:', error);
    return false;
  }
}