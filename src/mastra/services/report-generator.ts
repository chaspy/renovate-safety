/**
 * Report Generator Service
 * Handles unified report generation with GitHub links and proper execution stats
 */

import { translateRecommendations } from './translation-service.js';
import {
  generateMarkdownLink,
  autoDetectRepository,
  type GitHubLinkOptions
} from '../tools/github-link-generator.js';
import { getHighestRisk } from '../workflows/report-generator.js';
import type { ExecutionStats } from '../tools/execution-tracker.js';

// Helper function to get repository URL from package name
function getRepositoryUrl(packageName: string): string | null {
  // Common mappings for popular packages
  const packageRepoMap: Record<string, string> = {
    'p-limit': 'https://github.com/sindresorhus/p-limit',
    'react': 'https://github.com/facebook/react',
    'lodash': 'https://github.com/lodash/lodash',
    'typescript': 'https://github.com/microsoft/TypeScript',
  };
  
  return packageRepoMap[packageName] || null;
}

// Helper function to normalize file paths for main branch
function normalizeFilePath(filePath: string): string {
  // Remove line number suffix first
  const cleanPath = filePath.replace(/:?\d+$/, '');

  // Handle various path formats and extract the final src/... part
  // Use lastIndexOf for safer pattern matching (avoids ReDoS)
  if (cleanPath.includes('worktree-agent-version/src/')) {
    const idx = cleanPath.lastIndexOf('worktree-agent-version/src/');
    if (idx !== -1) {
      return cleanPath.substring(idx + 'worktree-agent-version/'.length);
    }
  }

  if (cleanPath.includes('/src/')) {
    const idx = cleanPath.lastIndexOf('/src/');
    if (idx !== -1) {
      return cleanPath.substring(idx + 1);
    }
  }
  
  // If it already starts with src/, just clean it up
  if (cleanPath.startsWith('src/')) {
    return cleanPath.replace(/^\/+/, '');
  }
  
  // Fallback: return as-is but remove leading slashes
  return cleanPath.replace(/^\/+/, '');
}

// Helper function to get risk emoji
function getRiskEmoji(risk: string): string {
  switch (risk.toLowerCase()) {
    case 'safe': return '‚úÖ';
    case 'low': return 'üü°';
    case 'medium': return 'üü†';
    case 'high': return 'üî¥';
    case 'critical': return 'üö®';
    default: return '‚ùì';
  }
}

// Unified report generation with GitHub links and proper execution stats
export async function generateUnifiedReport(assessments: any[], options: {
  format: 'markdown' | 'json';
  language: 'en' | 'ja';
  prInfo: any;
  executionStats?: ExecutionStats;
  includeExecutionStats?: boolean;
}) {
  const { format, language, prInfo, executionStats, includeExecutionStats = true } = options;
  
  if (format === 'json') {
    // Import the original generateReport function for JSON format
    const { generateReport } = await import('../workflows/report-generator.js');
    return generateReport(assessments, options);
  }
  
  // Generate markdown with GitHub links and translation support
  const isJapanese = language === 'ja';
  const overallRisk = getHighestRisk(assessments);
  const riskEmoji = getRiskEmoji(overallRisk);
  
  // Auto-detect repository for GitHub links
  let repository;
  let linkOptions: GitHubLinkOptions | undefined;
  
  try {
    repository = await autoDetectRepository(prInfo);
    if (repository) {
      linkOptions = { repository };
    }
  } catch (error) {
    console.warn('Could not auto-detect repository for links:', error);
  }
  
  let markdown = `### ${isJapanese ? 'renovate-safety ÂàÜÊûêÁµêÊûú' : 'renovate-safety Analysis'}\n\n`;
  markdown += `**${isJapanese ? 'ÁµêË´ñ' : 'Conclusion'}**: ${riskEmoji} ${overallRisk.toUpperCase()}\n\n`;
  
  // Summary section
  markdown += await generateSummarySection(assessments, isJapanese, linkOptions);
  
  // Individual assessments
  markdown += await generateAssessmentsSection(assessments, isJapanese, linkOptions);
  
  // Recommendations section
  markdown += await generateRecommendationsSection(assessments, overallRisk, isJapanese);
  
  // Execution statistics (using finalized stats)
  if (includeExecutionStats && executionStats) {
    markdown += generateExecutionStatsSection(executionStats, isJapanese);
  }
  
  return {
    format: 'markdown' as const,
    markdown,
  };
}

// Generate summary section with proper GitHub links
async function generateSummarySection(assessments: any[], isJapanese: boolean, linkOptions?: GitHubLinkOptions): Promise<string> {
  let markdown = `#### ${isJapanese ? 'üìä Ê¶ÇË¶Å' : 'üìä Summary'}\n\n`;
  
  const riskCounts = assessments.reduce((acc, a) => {
    acc[a.risk.level] = (acc[a.risk.level] || 0) + 1;
    return acc;
  }, {});
  
  // Risk distribution table
  markdown += '| Risk Level | Count |\n|---|---|\n';
  const riskLevels = ['critical', 'high', 'medium', 'low', 'safe'];
  for (const level of riskLevels) {
    if (riskCounts[level] > 0) {
      const emoji = getRiskEmoji(level);
      markdown += `| ${emoji} ${level.toUpperCase()} | ${riskCounts[level]} |\n`;
    }
  }
  markdown += '\n';
  
  return markdown;
}

// Generate assessments section with GitHub links  
// Generate library overview section
function generateLibraryOverviewSection(overview: any, isJapanese: boolean): string {
  if (!overview) return '';

  let section = `**${isJapanese ? '„É©„Ç§„Éñ„É©„É™Ê¶ÇË¶Å' : 'Library Overview'}**: ${overview.overview}\n\n`;
  if (overview.category && overview.category !== 'unknown') {
    section += `**${isJapanese ? '„Ç´„ÉÜ„Ç¥„É™' : 'Category'}**: ${overview.category}\n\n`;
  }
  return section;
}

// Generate functional summary section
async function generateFunctionalSummarySection(assessment: any, dependency: any, isJapanese: boolean): Promise<string> {
  const functionalSummary = await buildFunctionalSummary(assessment, isJapanese);
  if (functionalSummary.length === 0) return '';

  let section = isJapanese ? '**Ê©üËÉΩ„É¨„Éô„É´„ÅÆÂ§âÊõ¥ÔºàË¶ÅÁÇπÔºâ**:\n' : '**Functional Changes (Summary):**\n';
  for (const b of functionalSummary) {
    section += `- ${b}\n`;
  }

  // Upstream compare link when available
  const repoUrl = getRepositoryUrl(dependency.name);
  if (repoUrl) {
    const compareUrl = `${repoUrl}/compare/v${dependency.fromVersion}...v${dependency.toVersion}`;
    section += isJapanese
      ? `  - üîó [‰∏äÊµÅ„ÅÆÂ∑ÆÂàÜ (GitHub Compare)](${compareUrl})\n`
      : `  - üîó [Upstream Diff (GitHub Compare)](${compareUrl})\n`;
  }
  section += '\n';
  return section;
}

// Generate usage information section
function generateUsageInformationSection(codeImpact: any, isJapanese: boolean, linkOptions?: GitHubLinkOptions): string {
  if (!codeImpact || codeImpact.totalUsages === 0) return '';

  let section = `**${isJapanese ? 'Âà©Áî®ÁÆáÊâÄ' : 'Usage Locations'}**: ${codeImpact.totalUsages} ${isJapanese ? 'ÁÆáÊâÄ' : 'locations'}\n\n`;

  // Affected files with links
  section += generateAffectedFilesSection(codeImpact.affectedFiles, isJapanese, linkOptions);

  // Usage details
  section += generateUsageDetailsSection(codeImpact.usageDetails, isJapanese);

  return section;
}

// Generate affected files section
function generateAffectedFilesSection(affectedFiles: string[] | undefined, isJapanese: boolean, linkOptions?: GitHubLinkOptions): string {
  if (!affectedFiles || affectedFiles.length === 0) return '';

  let section = `**${isJapanese ? 'ÂΩ±Èüø„Éï„Ç°„Ç§„É´' : 'Affected Files'}**:\n`;

  for (const file of affectedFiles) {
    const normalizedFile = normalizeFilePath(file);

    if (linkOptions) {
      const link = generateMarkdownLink(normalizedFile, 1, linkOptions);
      section += `- ${link}`;
    } else {
      section += `- ${normalizedFile}`;
    }

    // Add context about the file
    section += getFileContext(file, isJapanese);
    section += '\n';
  }
  section += '\n';
  return section;
}

// Get file context description
function getFileContext(file: string, isJapanese: boolean): string {
  if (file.includes('parallel')) {
    return isJapanese ? ' (‰∏¶ÂàóÂá¶ÁêÜÂà∂Âæ°)' : ' (parallel processing control)';
  } else if (file.includes('helper')) {
    return isJapanese ? ' („Éò„É´„Éë„Éº„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£)' : ' (helper utilities)';
  } else if (file.includes('api') || file.includes('client')) {
    return isJapanese ? ' (APIÈÄö‰ø°)' : ' (API communication)';
  }
  return '';
}

// Generate usage details section
function generateUsageDetailsSection(usageDetails: any[] | undefined, isJapanese: boolean): string {
  if (!usageDetails || usageDetails.length === 0) return '';

  let section = `**${isJapanese ? 'Âà©Áî®ÂΩ¢ÊÖã' : 'Usage Patterns'}**:\n`;

  const usageTypes = groupUsageByType(usageDetails);

  section += formatImportUsage(usageTypes.import, isJapanese);
  section += formatFunctionCallUsage(usageTypes['function-call'], isJapanese);
  section += formatAssignmentUsage(usageTypes.assignment, isJapanese);
  section += formatFunctionDefinitionUsage(usageTypes['function-definition'], isJapanese);

  section += '\n';
  return section;
}

// Group usage details by type
function groupUsageByType(usageDetails: any[]): any {
  return usageDetails.reduce((acc: any, detail: any) => {
    if (!acc[detail.usage]) acc[detail.usage] = [];
    acc[detail.usage].push({
      context: detail.context,
      description: detail.description
    });
    return acc;
  }, {});
}

// Format import usage
function formatImportUsage(importUsages: any[] | undefined, isJapanese: boolean): string {
  if (!importUsages) return '';

  const importDetail = importUsages[0];
  let text = isJapanese ?
    `- **„Ç§„É≥„Éù„Éº„Éà**: ${importDetail.description || '„Éë„ÉÉ„Ç±„Éº„Ç∏„Çí„É¢„Ç∏„É•„Éº„É´„Å®„Åó„Å¶Ë™≠„ÅøËæº„Åø'}\n` :
    `- **Import**: ${importDetail.description || 'Loading package as module'}\n`;

  if (importDetail.context && importDetail.context.length < 100) {
    text += `  \`\`\`javascript\n  ${importDetail.context}\n  \`\`\`\n`;
  }
  return text;
}

// Format function call usage
function formatFunctionCallUsage(callUsages: any[] | undefined, isJapanese: boolean): string {
  if (!callUsages) return '';

  const callDetails = callUsages.slice(0, 2);
  let text = isJapanese ?
    `- **Èñ¢Êï∞Âëº„Å≥Âá∫„Åó**: ${callDetails.length}ÁÆáÊâÄ„ÅßÂÆüË°å\n` :
    `- **Function calls**: Executed in ${callDetails.length} locations\n`;

  callDetails.forEach((detail: any, index: number) => {
    if (detail.description) {
      text += `  ${index + 1}. ${detail.description}\n`;
    }
    if (detail.context && detail.context.length < 120) {
      text += `     \`${detail.context.replace(/\s+/g, ' ')}\`\n`;
    }
  });
  return text;
}

// Format assignment usage
function formatAssignmentUsage(assignmentUsages: any[] | undefined, isJapanese: boolean): string {
  if (!assignmentUsages) return '';

  const assignDetail = assignmentUsages[0];
  let text = isJapanese ?
    `- **Â§âÊï∞‰ª£ÂÖ•**: ${assignDetail.description || 'Èñ¢Êï∞ÁµêÊûú„ÇíÂ§âÊï∞„Å´Ê†ºÁ¥ç'}\n` :
    `- **Variable assignment**: ${assignDetail.description || 'Storing function results in variables'}\n`;

  if (assignDetail.context && assignDetail.context.length < 100) {
    text += `  \`${assignDetail.context.trim()}\`\n`;
  }
  return text;
}

// Format function definition usage
function formatFunctionDefinitionUsage(funcUsages: any[] | undefined, isJapanese: boolean): string {
  if (!funcUsages) return '';

  const funcDetails = funcUsages.slice(0, 2);
  return isJapanese ?
    `- **Èñ¢Êï∞ÂÆöÁæ©**: ${funcDetails.length}ÂÄã„ÅÆÈñ¢Êï∞„Åß„Éë„ÉÉ„Ç±„Éº„Ç∏„Çí‰ΩøÁî®\n` :
    `- **Function definitions**: Package used in ${funcDetails.length} function(s)\n`;
}

// Main assessment section generator (refactored)
async function generateAssessmentsSection(assessments: any[], isJapanese: boolean, linkOptions?: GitHubLinkOptions): Promise<string> {
  let markdown = `#### ${isJapanese ? 'üì¶ „Éë„ÉÉ„Ç±„Éº„Ç∏ÂàÜÊûê' : 'üì¶ Package Analysis'}\n\n`;

  for (const assessment of assessments) {
    const { dependency, overview, codeImpact, risk } = assessment;
    const riskEmoji = getRiskEmoji(risk.level);

    markdown += `##### ${dependency.name} ${dependency.fromVersion} ‚Üí ${dependency.toVersion} ${riskEmoji}\n\n`;

    // Library overview
    markdown += generateLibraryOverviewSection(overview, isJapanese);
    // Risk level and impact
    markdown += `**${isJapanese ? '„É™„Çπ„ÇØ„É¨„Éô„É´' : 'Risk Level'}**: ${risk.level.toUpperCase()} (${isJapanese ? '„Çπ„Ç≥„Ç¢' : 'Score'}: ${risk.score})\n\n`;

    // Risk assessment breakdown
    markdown += await generateRiskAssessmentBreakdown(assessment, isJapanese);

    // Functional summary
    markdown += await generateFunctionalSummarySection(assessment, dependency, isJapanese);

    // Usage information
    markdown += generateUsageInformationSection(codeImpact, isJapanese, linkOptions);

    // Recommendations
    markdown += await generateCodeImpactRecommendations(codeImpact, isJapanese);
  }

  return markdown;
}

// Generate code impact recommendations
async function generateCodeImpactRecommendations(codeImpact: any, isJapanese: boolean): Promise<string> {
  if (!codeImpact?.recommendations?.length) return '';

  let section = `**${isJapanese ? 'Êé®Â•®„Ç¢„ÇØ„Ç∑„Éß„É≥' : 'Recommendations'}**:\n`;

  const translatedRecommendations = await translateRecommendations(
    codeImpact.recommendations,
    isJapanese ? 'ja' : 'en'
  );

  for (const rec of translatedRecommendations) {
    section += `- ${rec}\n`;
  }
  section += '\n';
  return section;
}

// Build high-level functional change bullets from available context
async function buildFunctionalSummary(assessment: any, isJapanese: boolean): Promise<string[]> {
  try {
    const bullets: string[] = [];
    const dep = assessment.dependency || {};
    const releaseNotes = assessment.releaseNotes || {};

    // Process breaking changes
    const breakingBullets = await processBreakingChanges(releaseNotes, isJapanese);
    bullets.push(...breakingBullets);

    // Add version jump context
    const versionBullet = getVersionJumpBullet(dep.fromVersion, dep.toVersion, isJapanese);
    if (versionBullet) {
      bullets.push(versionBullet);
    }

    // Add fallback bullets if no changes detected
    if (bullets.length === 0) {
      const fallbackBullets = getFallbackBullets(assessment, isJapanese);
      bullets.push(...fallbackBullets);
    }

    return bullets.slice(0, 5);
  } catch {
    return [];
  }
}

async function processBreakingChanges(
  releaseNotes: any,
  isJapanese: boolean
): Promise<string[]> {
  const breaking = Array.isArray(releaseNotes.breakingChanges)
    ? releaseNotes.breakingChanges
    : [];

  if (breaking.length === 0) {
    return [];
  }

  const texts = breaking
    .map((bc: any) =>
      typeof bc === 'string' ? bc : bc.text || bc.description || ''
    )
    .filter(Boolean)
    .slice(0, 3);

  return isJapanese ? await translateRecommendations(texts, 'ja') : texts;
}

function getVersionJumpBullet(
  fromVersion: string | undefined,
  toVersion: string | undefined,
  isJapanese: boolean
): string | null {
  const majorJump = getMajorJump(fromVersion, toVersion);

  if (majorJump > 0) {
    return isJapanese
      ? `„É°„Ç∏„É£„Éº„Éê„Éº„Ç∏„Éß„É≥Êõ¥Êñ∞Ôºà+${majorJump}Ôºâ: ‰∫íÊèõÊÄß„Å´Ê≥®ÊÑè`
      : `Major version update (+${majorJump}): Backward compatibility may be affected`;
  }

  return null;
}

function getFallbackBullets(assessment: any, isJapanese: boolean): string[] {
  const bullets: string[] = [];

  bullets.push(
    isJapanese
      ? 'Á†¥Â£äÁöÑÂ§âÊõ¥„ÅØÊ§úÂá∫„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„ÇìÔºàËá™ÂãïËß£ÊûêÔºâ'
      : 'No breaking API changes detected by automated analysis'
  );

  if (assessment.codeImpact?.totalUsages >= 0) {
    const n = assessment.codeImpact.totalUsages;
    bullets.push(
      isJapanese
        ? `Êú¨„É™„Éù„Ç∏„Éà„É™„Åß„ÅÆÂà©Áî®ÁÆáÊâÄ: ${n} ÁÆáÊâÄ`
        : `Usage in this repo: ${n} locations`
    );
  }

  return bullets;
}

function getMajorJump(from?: string, to?: string): number {
  try {
    if (!from || !to) return 0;
    const a = parseInt(String(from).split('.')[0] || '0', 10) || 0;
    const b = parseInt(String(to).split('.')[0] || '0', 10) || 0;
    return Math.max(0, b - a);
  } catch {
    return 0;
  }
}

// Generate recommendations section with translation
async function generateRecommendationsSection(assessments: any[], overallRisk: string, isJapanese: boolean): Promise<string> {
  let markdown = `#### ${isJapanese ? 'üìå ÂÖ®‰ΩìÁöÑ„Å™Êé®Â•®„Ç¢„ÇØ„Ç∑„Éß„É≥' : 'üìå Overall Recommendations'}\n\n`;
  
  // Generate general recommendations based on overall risk
  const recommendations = [];
  
  if (overallRisk === 'critical' || overallRisk === 'high') {
    recommendations.push('Run comprehensive tests before merging');
    recommendations.push('Consider manual testing for critical functionality');
    recommendations.push('Review breaking changes carefully');
  } else if (overallRisk === 'medium') {
    recommendations.push('Run unit and integration tests');
    recommendations.push('Monitor for any runtime issues');
  } else {
    recommendations.push('Standard testing should be sufficient');
    recommendations.push('Monitor deployment for any unexpected issues');
  }
  
  const translatedRecommendations = await translateRecommendations(
    recommendations, 
    isJapanese ? 'ja' : 'en'
  );
  
  for (const rec of translatedRecommendations) {
    markdown += `- ${rec}\n`;
  }
  markdown += '\n';
  
  return markdown;
}

// Generate execution statistics section
function generateExecutionStatsSection(stats: ExecutionStats, isJapanese: boolean): string {
  let markdown = `<details>\n<summary><small><em>${isJapanese ? 'üìä ÂÆüË°åÁµ±Ë®à' : 'üìä Execution Statistics'}</em></small></summary>\n\n`;
  markdown += '<small><em>\n\n';

  markdown += formatDurationStats(stats, isJapanese);
  markdown += formatAgentStats(stats, isJapanese);
  markdown += formatApiCallStats(stats, isJapanese);
  markdown += formatTokenStats(stats, isJapanese);
  markdown += formatCostStats(stats, isJapanese);
  markdown += formatDataSourceStats(stats, isJapanese);

  markdown += '\n</em></small>\n</details>\n\n';

  return markdown;
}

function formatDurationStats(stats: ExecutionStats, isJapanese: boolean): string {
  if (!stats.totalDuration) return '';
  const duration = Math.round(stats.totalDuration / 1000);
  return `- ${isJapanese ? 'ÂÆüË°åÊôÇÈñì' : 'Duration'}: ${duration}s\n`;
}

function formatAgentStats(stats: ExecutionStats, isJapanese: boolean): string {
  let result = `- ${isJapanese ? '„Ç®„Éº„Ç∏„Çß„É≥„ÉàÊï∞' : 'Agents Used'}: ${stats.agents.length}\n`;

  const agentNames = stats.agents.map(agent => agent.agentName).join(', ');
  if (agentNames) {
    result += `  - ${isJapanese ? '‰ΩøÁî®„Ç®„Éº„Ç∏„Çß„É≥„Éà' : 'Agent Names'}: ${agentNames}\n`;
  }

  return result;
}

function formatApiCallStats(stats: ExecutionStats, isJapanese: boolean): string {
  let result = `- ${isJapanese ? 'APIÂëº„Å≥Âá∫„Åó' : 'API Calls'}: ${stats.apiCalls.total}\n`;

  const modelBreakdown = Object.entries(stats.apiCalls.byModel)
    .map(([model, count]) => `${model}: ${count}`)
    .join(', ');

  if (modelBreakdown) {
    result += `  - ${isJapanese ? '„É¢„Éá„É´Âà•' : 'By Model'}: ${modelBreakdown}\n`;
  }

  return result;
}

function formatTokenStats(stats: ExecutionStats, isJapanese: boolean): string {
  const totalTokens = stats.agents.reduce((sum, agent) => sum + (agent.totalTokens || 0), 0);
  if (totalTokens === 0) return '';

  let result = `- ${isJapanese ? '„Éà„Éº„ÇØ„É≥‰ΩøÁî®Èáè' : 'Token Usage'}: ${totalTokens.toLocaleString()}\n`;

  const inputTokens = stats.agents.reduce((sum, agent) => sum + (agent.inputTokens || 0), 0);
  const outputTokens = stats.agents.reduce((sum, agent) => sum + (agent.outputTokens || 0), 0);

  if (inputTokens > 0 && outputTokens > 0) {
    result += `  - ${isJapanese ? 'ÂÖ•Âäõ/Âá∫Âäõ' : 'Input/Output'}: ${inputTokens.toLocaleString()}/${outputTokens.toLocaleString()}\n`;
  }

  return result;
}

function formatCostStats(stats: ExecutionStats, isJapanese: boolean): string {
  if (stats.apiCalls.estimatedCost === undefined) return '';
  const cost = stats.apiCalls.estimatedCost.toFixed(4);
  return `- ${isJapanese ? 'Êé®ÂÆö„Ç≥„Çπ„Éà' : 'Estimated Cost'}: $${cost}\n`;
}

function formatDataSourceStats(stats: ExecutionStats, isJapanese: boolean): string {
  if (!stats.dataSourcesUsed || stats.dataSourcesUsed.length === 0) return '';
  const dataSources = stats.dataSourcesUsed.join(', ');
  return `- ${isJapanese ? '„Éá„Éº„Çø„ÇΩ„Éº„Çπ' : 'Data Sources'}: ${dataSources}\n`;
}

// Generate detailed risk assessment breakdown
async function generateRiskAssessmentBreakdown(assessment: any, isJapanese: boolean): Promise<string> {
  const { dependency, risk, releaseNotes, codeImpact } = assessment;
  let markdown = '';

  // Skip breakdown for safe packages
  if (risk.level === 'safe') {
    return '';
  }

  markdown += `<details>\n<summary><strong>${isJapanese ? 'üìã „É™„Çπ„ÇØ„Ç¢„Çª„Çπ„É°„É≥„ÉàË©≥Á¥∞' : 'üìã Risk Assessment Details'}</strong></summary>\n\n`;
  
  // Version change analysis
  const isMajorUpdate = dependency.fromVersion.split('.')[0] !== dependency.toVersion.split('.')[0];
  const isMinorUpdate = !isMajorUpdate && dependency.fromVersion.split('.')[1] !== dependency.toVersion.split('.')[1];
  
  markdown += `**${isJapanese ? '„Éê„Éº„Ç∏„Éß„É≥Â§âÊõ¥ÂàÜÊûê' : 'Version Change Analysis'}**:\n`;
  
  if (isMajorUpdate) {
    const scoreContribution = 20;
    markdown += isJapanese ? 
      `- „É°„Ç∏„É£„Éº„Éê„Éº„Ç∏„Éß„É≥„Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„Éâ (${dependency.fromVersion} ‚Üí ${dependency.toVersion}): **+${scoreContribution}ÁÇπ**\n` :
      `- Major version upgrade (${dependency.fromVersion} ‚Üí ${dependency.toVersion}): **+${scoreContribution} points**\n`;
    markdown += isJapanese ?
      '  - „É°„Ç∏„É£„ÉºÊõ¥Êñ∞„ÅØÁ†¥Â£äÁöÑÂ§âÊõ¥„ÇíÂê´„ÇÄÂèØËÉΩÊÄß„ÅåÈ´ò„ÅÑ„Åü„ÇÅ„ÄÅÈ´ò„ÅÑ„Çπ„Ç≥„Ç¢„Åå‰ªò‰∏é„Åï„Çå„Åæ„Åô\n' :
      '  - Major updates have high potential for breaking changes, resulting in higher scores\n';
  } else if (isMinorUpdate) {
    const scoreContribution = 5;
    markdown += isJapanese ?
      `- „Éû„Ç§„Éä„Éº„Éê„Éº„Ç∏„Éß„É≥Êõ¥Êñ∞ (${dependency.fromVersion} ‚Üí ${dependency.toVersion}): **+${scoreContribution}ÁÇπ**\n` :
      `- Minor version update (${dependency.fromVersion} ‚Üí ${dependency.toVersion}): **+${scoreContribution} points**\n`;
  } else {
    const scoreContribution = 1;
    markdown += isJapanese ?
      `- „Éë„ÉÉ„ÉÅ„Éê„Éº„Ç∏„Éß„É≥Êõ¥Êñ∞ (${dependency.fromVersion} ‚Üí ${dependency.toVersion}): **+${scoreContribution}ÁÇπ**\n` :
      `- Patch version update (${dependency.fromVersion} ‚Üí ${dependency.toVersion}): **+${scoreContribution} point**\n`;
  }

  // Usage impact (detailed breakdown)
  if (codeImpact?.totalUsages > 0) {
    const usageScore = Math.min(codeImpact.totalUsages * 2, 20);
    const criticalPathScore = codeImpact?.criticalUsages > 0 ? 10 : 0;
    const totalUsageScore = usageScore + criticalPathScore;
    
    markdown += isJapanese ?
      `- **„Ç≥„Éº„Éâ‰ΩøÁî®ÁÆáÊâÄ„ÅÆÂΩ±Èüø**: **+${totalUsageScore}ÁÇπ**\n` :
      `- **Code usage impact**: **+${totalUsageScore} points**\n`;
    markdown += isJapanese ?
      `  - ‰ΩøÁî®ÁÆáÊâÄÊï∞ (${codeImpact.totalUsages}ÁÆáÊâÄ): +${usageScore}ÁÇπ (${codeImpact.totalUsages} √ó 2ÁÇπ, ÊúÄÂ§ß20ÁÇπ)\n` :
      `  - Usage locations (${codeImpact.totalUsages} locations): +${usageScore} points (${codeImpact.totalUsages} √ó 2 points, max 20)\n`;
    
    if (criticalPathScore > 0) {
      markdown += isJapanese ?
        `  - „ÇØ„É™„ÉÜ„Ç£„Ç´„É´„Éë„Çπ‰ΩøÁî®: +${criticalPathScore}ÁÇπ\n` :
        `  - Critical path usage: +${criticalPathScore} points\n`;
    }
  } else {
    markdown += isJapanese ?
      '- **„Ç≥„Éº„Éâ‰ΩøÁî®ÁÆáÊâÄ„ÅÆÂΩ±Èüø**: **+0ÁÇπ** (‰ΩøÁî®ÁÆáÊâÄ„Å™„Åó)\n' :
      '- **Code usage impact**: **+0 points** (no usage locations)\n';
  }
  
  // Information availability impact
  const hasLowInfo = risk.factors.some((factor: string) => factor.includes('Limited information'));
  if (hasLowInfo) {
    markdown += isJapanese ?
      '- **ÊÉÖÂ†±‰∏çË∂≥„Å´„Çà„Çã„Éö„Éä„É´„ÉÜ„Ç£**: **+5„Äú10ÁÇπ**\n' :
      '- **Information unavailability penalty**: **+5-10 points**\n';
    markdown += isJapanese ?
      '  - ÈôêÂÆöÁöÑ„Å™ÊÉÖÂ†±„ÅÆ„Åü„ÇÅ„ÄÅ„É™„Çπ„ÇØ„Çí‰øùÂÆàÁöÑ„Å´Ë©ï‰æ°„Åó„Å¶„ÅÑ„Åæ„Åô\n' :
      '  - Conservative risk assessment due to limited information\n';
  }
  
  // Test coverage mitigation
  if (codeImpact?.testCoverage && codeImpact.testCoverage > 0) {
    const testReduction = Math.round((codeImpact.testCoverage / 100) * 20);
    markdown += isJapanese ?
      `- **„ÉÜ„Çπ„Éà„Ç´„Éê„É¨„ÉÉ„Ç∏„Å´„Çà„ÇãËªΩÊ∏õ**: **-${testReduction}ÁÇπ** („Ç´„Éê„É¨„ÉÉ„Ç∏ ${codeImpact.testCoverage}%)\n` :
      `- **Test coverage mitigation**: **-${testReduction} points** (${codeImpact.testCoverage}% coverage)\n`;
  }
  
  // Package type adjustments
  const isTypesDef = dependency.name.startsWith('@types/');
  const isDevDep = risk.factors.some((factor: string) => factor.includes('Development dependency'));
  const isLockfileOnly = risk.factors.some((factor: string) => factor.includes('Lockfile-only'));
  
  if (isTypesDef || isDevDep || isLockfileOnly) {
    markdown += `\n**${isJapanese ? 'ÁâπÂà•Ë™øÊï¥' : 'Special Adjustments'}**:\n`;
    
    if (isTypesDef) {
      markdown += isJapanese ?
        '- @types/* „Éë„ÉÉ„Ç±„Éº„Ç∏„ÅÆ„Åü„ÇÅÂ§ßÂπÖ„Å™„É™„Çπ„ÇØËªΩÊ∏õ„ÅåÈÅ©Áî®„Åï„Çå„Å¶„ÅÑ„Åæ„Åô\n' :
        '- Significant risk reduction applied for @types/* package\n';
    }
    
    if (isDevDep) {
      markdown += isJapanese ?
        '- ÈñãÁô∫‰æùÂ≠òÈñ¢‰øÇ„ÅÆ„Åü„ÇÅËªΩÂæÆ„Å™„É™„Çπ„ÇØËªΩÊ∏õ„ÅåÈÅ©Áî®„Åï„Çå„Å¶„ÅÑ„Åæ„Åô (-1ÁÇπ)\n' :
        '- Minor risk reduction applied for development dependency (-1 point)\n';
    }
    
    if (isLockfileOnly) {
      markdown += isJapanese ?
        '- lockfile-only„ÅÆÂ§âÊõ¥„ÅÆ„Åü„ÇÅÂ§ßÂπÖ„Å™„É™„Çπ„ÇØËªΩÊ∏õ„ÅåÈÅ©Áî®„Åï„Çå„Å¶„ÅÑ„Åæ„Åô (ÊúÄÂ§ß10ÁÇπ„Å´Âà∂Èôê)\n' :
        '- Significant risk reduction applied for lockfile-only change (capped at 10 points)\n';
    }
  }

  // Breaking changes detection status
  const hasBreakingChanges = risk.factors.some((factor: string) => factor.includes('breaking changes'));
  const breakingChangeCount = hasBreakingChanges ? 
    parseInt((/(\d+)/.exec(risk.factors.find((f: string) => f.includes('breaking changes')) || ''))?.[1] || '0') : 0;

  markdown += `\n**${isJapanese ? 'Á†¥Â£äÁöÑÂ§âÊõ¥„ÅÆÊ§úÂá∫Áä∂Ê≥Å' : 'Breaking Changes Detection'}**:\n`;
  
  if (breakingChangeCount > 0) {
    // Calculate actual score impact (matching RiskArbiter logic)
    const actualBreakingChangeScore = Math.min(breakingChangeCount * 5, 20);
    
    markdown += isJapanese ?
      `- **${breakingChangeCount}‰ª∂„ÅÆÁ†¥Â£äÁöÑÂ§âÊõ¥„ÇíÊ§úÂá∫**: **+${actualBreakingChangeScore}ÁÇπ** (${breakingChangeCount}‰ª∂ √ó 5ÁÇπ, ÊúÄÂ§ß20ÁÇπ)\n` :
      `- **${breakingChangeCount} breaking changes detected**: **+${actualBreakingChangeScore} points** (${breakingChangeCount} changes √ó 5 points, max 20)\n`;
    
    if (releaseNotes?.breakingChanges && releaseNotes.breakingChanges.length > 0) {
      markdown += isJapanese ? '\n  **Ë©≥Á¥∞:**\n\n' : '\n  **Details:**\n\n';
      
      releaseNotes.breakingChanges.forEach((change: any, index: number) => {
        const changeText = change.text || change;
        const severity = change.severity || 'breaking';
        const source = change.source || 'npm-diff-tool';
        
        // All breaking changes contribute 5 points each (per RiskArbiter logic)
        const pointsContribution = 5;
        
        markdown += `  ${index + 1}. **${changeText}** (+${pointsContribution}${isJapanese ? 'ÁÇπ' : ' points'})\n`;
        markdown += `     - ${isJapanese ? 'ÈáçË¶ÅÂ∫¶' : 'Severity'}: ${severity.toUpperCase()}\n`;
        markdown += `     - ${isJapanese ? '„ÇΩ„Éº„Çπ' : 'Source'}: ${source}\n`;
        
        // Add source links where available
        let referenceLink = '';
        
        if (source === 'npm-diff') {
          // For npm-diff, provide GitHub compare link or npm diff command
          const repoUrl = getRepositoryUrl(dependency.name);
          if (repoUrl) {
            referenceLink = `[GitHub Compare](${repoUrl}/compare/v${dependency.fromVersion}...v${dependency.toVersion})`;
            markdown += `     - ${isJapanese ? 'Á¢∫Ë™ç„É™„É≥„ÇØ' : 'Reference'}: ${referenceLink}\n`;
          }
          markdown += `     - ${isJapanese ? 'npm diff „Ç≥„Éû„É≥„Éâ' : 'npm diff command'}: \`npm diff ${dependency.name}@${dependency.fromVersion} ${dependency.name}@${dependency.toVersion}\`\n`;
        } else if (source === 'GitHub release notes' || source === 'GitHub Releases') {
          // For GitHub releases, use the actual release URL
          const repoUrl = getRepositoryUrl(dependency.name);
          if (repoUrl) {
            referenceLink = `[GitHub Release v${dependency.toVersion}](${repoUrl}/releases/tag/v${dependency.toVersion})`;
            markdown += `     - ${isJapanese ? 'Á¢∫Ë™ç„É™„É≥„ÇØ' : 'Reference'}: ${referenceLink}\n`;
          }
        } else if (releaseNotes?.sources) {
          // Fallback: try to find matching source
          const sourceInfo = releaseNotes.sources.find((s: any) => 
            s.type === source || s.type.includes(source) || source.includes(s.type)
          );
          if (sourceInfo?.url) {
            markdown += `     - ${isJapanese ? 'Á¢∫Ë™ç„É™„É≥„ÇØ' : 'Reference'}: [${sourceInfo.type}](${sourceInfo.url})\n`;
          }
        }
        
        // Add impact explanation for critical changes
        if (changeText.includes('Node.js requirement')) {
          markdown += isJapanese ?
            `     - üí° Node.jsË¶Å‰ª∂Â§âÊõ¥„ÅØÂÆüË°åÁí∞Â¢É„Å´Áõ¥Êé•ÂΩ±Èüø„Åô„ÇãÈáçË¶Å„Å™Â§âÊõ¥„Åß„Åô\n` :
            `     - üí° Node.js requirement changes directly impact the runtime environment\n`;
        }
        
        markdown += '\n';
      });
      
      // Add sources summary if available
      if (releaseNotes?.sources && releaseNotes.sources.length > 0) {
        markdown += `  **${isJapanese ? '„Éá„Éº„Çø„ÇΩ„Éº„Çπ' : 'Data Sources'}**:\n`;
        releaseNotes.sources.forEach((source: any) => {
          const status = source.status === 'success' ? '‚úÖ' : '‚ùå';
          if (source.url) {
            markdown += `  - ${status} [${source.type}](${source.url})\n`;
          } else {
            markdown += `  - ${status} ${source.type}\n`;
          }
        });
        markdown += '\n';
      }
    }
  } else if (isMajorUpdate) {
    // Major version with no detected breaking changes - highlight uncertainty
    markdown += isJapanese ? 
      '- **Á†¥Â£äÁöÑÂ§âÊõ¥„ÅØÊ§úÂá∫„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü„Åå„ÄÅ„É°„Ç∏„É£„Éº„Éê„Éº„Ç∏„Éß„É≥„Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„Éâ„ÅÆ„Åü„ÇÅÊΩúÂú®ÁöÑ„É™„Çπ„ÇØ„ÅåÂ≠òÂú®„Åó„Åæ„Åô**\n' :
      '- **No breaking changes detected, but potential risks exist due to major version upgrade**\n';
    markdown += isJapanese ?
      '  - ‚ö†Ô∏è „É™„É™„Éº„Çπ„Éé„Éº„Éà„ÅÆÂàÜÊûê„ÅßÂÖ∑‰ΩìÁöÑ„Å™Â§âÊõ¥ÂÜÖÂÆπ„ÇíÁâπÂÆö„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü\n' :
      '  - ‚ö†Ô∏è Release notes analysis could not identify specific changes\n';
    markdown += isJapanese ?
      '  - ÊâãÂãï„Åß„ÅÆÂ§âÊõ¥ÂÜÖÂÆπÁ¢∫Ë™ç„ÇíÂº∑„ÅèÊé®Â•®„Åó„Åæ„Åô\n' :
      '  - Manual review of changes is strongly recommended\n';
  } else {
    markdown += isJapanese ?
      '- Á†¥Â£äÁöÑÂ§âÊõ¥„ÅØÊ§úÂá∫„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü: **+0ÁÇπ**\n' :
      '- No breaking changes detected: **+0 points**\n';
  }
  
  // Add usage impact analysis if available
  if (assessment.usageImpact) {
    const { usageImpact } = assessment;
    
    markdown += `\n**${isJapanese ? 'ÂÆüÈöõ„ÅÆ„Ç≥„Éº„ÉâÂΩ±ÈüøÂàÜÊûê' : 'Actual Code Impact Analysis'}**:\n`;
    
    if (usageImpact.isAffected) {
      const riskEmoji = {
        'high': 'üî¥',
        'medium': 'üü°', 
        'low': 'üü¢',
        'none': '‚ö™'
      }[usageImpact.riskLevel];
      
      markdown += isJapanese ?
        `- **ÂÆüÈöõ„Å´ÂΩ±Èüø„ÇíÂèó„Åë„Çã„Ç≥„Éº„Éâ„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åó„Åü** ${riskEmoji} **${usageImpact.riskLevel.toUpperCase()}„É™„Çπ„ÇØ**\n` :
        `- **Code actually affected by breaking changes detected** ${riskEmoji} **${usageImpact.riskLevel.toUpperCase()} risk**\n`;
      
      markdown += isJapanese ?
        `- **‰ø°È†ºÂ∫¶**: ${Math.round(usageImpact.confidence * 100)}%\n` :
        `- **Confidence**: ${Math.round(usageImpact.confidence * 100)}%\n`;
      
      if (usageImpact.affectedFiles.length > 0) {
        markdown += `\n  **${isJapanese ? 'ÂΩ±Èüø„Éï„Ç°„Ç§„É´' : 'Affected Files'}**:\n`;
        usageImpact.affectedFiles.forEach(file => {
          markdown += `  - [${file}]\n`;
        });
      }
      
      if (usageImpact.affectedPatterns.length > 0) {
        markdown += `\n  **${isJapanese ? 'Ê§úÂá∫„Éë„Çø„Éº„É≥' : 'Detected Patterns'}**:\n`;
        usageImpact.affectedPatterns.forEach(pattern => {
          markdown += `  - ${pattern}\n`;
        });
      }
      
      if (usageImpact.recommendations.length > 0) {
        markdown += `\n  **${isJapanese ? 'ÂØæÁ≠ñÊé®Â•®‰∫ãÈ†Ö' : 'Recommendations'}**:\n`;
        usageImpact.recommendations.forEach(rec => {
          markdown += `  - ${rec}\n`;
        });
      }
      
    } else {
      markdown += isJapanese ?
        `- **ÂÆüÈöõ„ÅÆÂΩ±Èüø„Å™„Åó** ‚ö™ Á†¥Â£äÁöÑÂ§âÊõ¥„ÅØ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆ„Ç≥„Éº„Éâ„Å´Áõ¥Êé•ÂΩ±Èüø„Åó„Åæ„Åõ„Çì\n` :
        `- **No actual impact** ‚ö™ Breaking changes do not directly affect project code\n`;
      
      markdown += isJapanese ?
        `- **‰ø°È†ºÂ∫¶**: ${Math.round(usageImpact.confidence * 100)}%\n` :
        `- **Confidence**: ${Math.round(usageImpact.confidence * 100)}%\n`;
        
      if (usageImpact.recommendations.length > 0) {
        markdown += `\n  **${isJapanese ? 'Êé®Â•®‰∫ãÈ†Ö' : 'Recommendations'}**:\n`;
        usageImpact.recommendations.forEach(rec => {
          markdown += `  - ${rec}\n`;
        });
      }
    }
    
    markdown += '\n';
  }

  // Information availability and confidence
  const hasLowConfidence = risk.confidence < 0.5;
  if (hasLowConfidence) {
    markdown += `\n**${isJapanese ? 'ÊÉÖÂ†±„ÅÆ‰∏çÁ¢∫ÂÆüÊÄß' : 'Information Uncertainty'}**:\n`;
    markdown += isJapanese ?
      `- ÂàÜÊûê„ÅÆ‰ø°È†ºÂ∫¶: **${Math.round(risk.confidence * 100)}%**\n` :
      `- Analysis confidence: **${Math.round(risk.confidence * 100)}%**\n`;
    
    if (risk.confidence < 0.3) {
      markdown += isJapanese ?
        '  - ‚ö†Ô∏è Âà©Áî®ÂèØËÉΩ„Å™ÊÉÖÂ†±„ÅåÈôêÂÆöÁöÑ„Åß„ÄÅ„É™„Çπ„ÇØ„ÅÆÈÅéÂ∞èË©ï‰æ°„ÅÆÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô\n' :
        '  - ‚ö†Ô∏è Limited information available, potential for risk underestimation\n';
      markdown += isJapanese ?
        '  - „Çà„Çä‰øùÂÆàÁöÑ„Å™„ÉÜ„Çπ„Éà„Ç¢„Éó„É≠„Éº„ÉÅ„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ\n' :
        '  - Consider a more conservative testing approach\n';
    }
  }

  // Testing recommendation rationale
  markdown += `\n**${isJapanese ? '„ÉÜ„Çπ„ÉàÊà¶Áï•„ÅÆÊ†πÊã†' : 'Testing Strategy Rationale'}**:\n`;
  markdown += isJapanese ?
    `- Êé®Â•®„ÉÜ„Çπ„Éà„Çπ„Ç≥„Éº„Éó: **${risk.testingScope}**\n` :
    `- Recommended testing scope: **${risk.testingScope}**\n`;
  markdown += isJapanese ?
    `- ‰∫àÊÉ≥Â∑•Êï∞: **${risk.estimatedEffort}**\n` :
    `- Estimated effort: **${risk.estimatedEffort}**\n`;

  if (risk.testingScope === 'unit' && isMajorUpdate && !hasBreakingChanges) {
    markdown += isJapanese ?
      '- ‚ö†Ô∏è „É°„Ç∏„É£„ÉºÊõ¥Êñ∞„ÅßÁ†¥Â£äÁöÑÂ§âÊõ¥„Åå‰∏çÊòé„Å™„Åü„ÇÅ„ÄÅÁµ±Âêà„ÉÜ„Çπ„Éà„ÇÇÊ§úË®é„Åô„Çã„Åì„Å®„ÇíÊé®Â•®„Åó„Åæ„Åô\n' :
      '- ‚ö†Ô∏è For major updates with unclear breaking changes, consider integration testing as well\n';
  }

  markdown += '\n</details>\n\n';
  
  return markdown;
}
